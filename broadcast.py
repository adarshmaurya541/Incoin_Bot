from pyrogram import filters
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from pymongo import MongoClient
from config import OWNER_ID, MONGO_URI, MONGO_DB_NAME
import asyncio
from pyrogram.enums import ParseMode

# MongoDB setup
mongo_client = MongoClient(MONGO_URI)
db = mongo_client[MONGO_DB_NAME]
started_users = db["started_users"]

last_broadcast_msg = {
    "cancel": False,
    "message_id_map": {},
    "target_message": None,
    "confirmation_received": False,
    "users": [],
    "message": None,
    "confirmation_msg": None
}

async def get_users():
    return list(started_users.distinct("user_id"))

def setup_broadcast_handlers(app):

    async def send_msg(user_id, message):
        try:
            sent = await app.copy_message(
                chat_id=user_id,
                from_chat_id=message.chat.id,
                message_id=message.id
            )
            return sent.message_id
        except Exception:
            return None

    async def send_broadcast_confirmation(app, message, users, confirm_buttons):
        countdown = 60
        confirmation_msg = await message.reply(
            f"üì£ **Broadcast Confirmation**\n\n"
            f"Do you want to send this message to all users?\n\n"
            f"üë• Users to send: `{len(users)}`\n‚è≥ Time left: `{countdown}` seconds",
            reply_markup=confirm_buttons,
            parse_mode=ParseMode.MARKDOWN
        )

        last_broadcast_msg.update({
            "confirmation_received": False,
            "confirmation_msg": confirmation_msg,
            "users": users,
            "message": message,
            "cancel": False
        })

        for seconds_left in range(countdown - 1, -1, -1):
            await asyncio.sleep(1)
            if last_broadcast_msg.get("confirmation_received", False) or last_broadcast_msg.get("cancel", False):
                return confirmation_msg
            try:
                await confirmation_msg.edit_text(
                    f"üì£ **Broadcast Confirmation**\n\n"
                    f"Do you want to send this message to all users?\n\n"
                    f"üë• Users to send: `{len(users)}`\n‚è≥ Time left: `{seconds_left}` seconds",
                    reply_markup=confirm_buttons,
                    parse_mode=ParseMode.MARKDOWN
                )
            except:
                break

        if not last_broadcast_msg.get("confirmation_received", False):
            try:
                await confirmation_msg.edit(
                    "‚ùå **Broadcast cancelled due to timeout.**",
                    reply_markup=None
                )
            except:
                pass
        return confirmation_msg

    @app.on_message(filters.command("gcast") & filters.user(OWNER_ID))
    async def gcast_command(_, message: Message):
        if not message.reply_to_message:
            return await message.reply_text("‚ö†Ô∏è  Ä·¥á·¥ò ü è ·¥õ·¥è ·¥Ä ·¥ç·¥áss·¥Ä…¢·¥á ·¥õ·¥è  ô Ä·¥è·¥Ä·¥Ö·¥Ñ·¥Äs·¥õ …™·¥õ.")

        users = await get_users()
        if not users:
            return await message.reply("üòï …¥·¥è ·¥ús·¥á Äs ·¥õ·¥è  ô Ä·¥è·¥Ä·¥Ö·¥Ñ·¥Äs·¥õ ·¥õ·¥è.")

        confirm_buttons = InlineKeyboardMarkup([[ 
            InlineKeyboardButton("‚úÖ Confirm", callback_data="confirm_broadcast"),
            InlineKeyboardButton("‚ùå Cancel", callback_data="cancel_broadcast")
        ]])

        await send_broadcast_confirmation(app, message, users, confirm_buttons)

    @app.on_callback_query(filters.regex("confirm_broadcast"))
    async def confirm_broadcast_handler(_, query: CallbackQuery):
        if query.from_user.id != OWNER_ID:
            return await query.answer("‚ùå Not allowed!", show_alert=True)

        if last_broadcast_msg.get("confirmation_received"):
            return await query.answer("‚úÖ Already confirmed.")

        last_broadcast_msg["confirmation_received"] = True
        await query.message.edit("üì¢ **Broadcast initiated...**", reply_markup=None)

        await broadcast_handler(
            app,
            last_broadcast_msg["message"],
            last_broadcast_msg["users"],
            last_broadcast_msg["confirmation_msg"]
        )

    async def broadcast_handler(app, message, users, confirmation_msg):
        cancel_btn = InlineKeyboardMarkup([
            [InlineKeyboardButton("üî¥ ·¥Ñ·¥Ä…¥·¥Ñ·¥á ü  ô Ä·¥è·¥Ä·¥Ö·¥Ñ·¥Äs·¥õ", callback_data="cancel_broadcast")]
        ])
        status_msg = await confirmation_msg.reply(
            f"üì§  ô Ä·¥è·¥Ä·¥Ö·¥Ñ·¥Äs·¥õ…™…¥…¢...\n\n‚úÖ 0/{len(users)} s·¥á…¥·¥õ | ‚ùå 0 “ì·¥Ä…™ ü·¥á·¥Ö",
            reply_markup=cancel_btn
        )

        done, failed = 0, 0
        last_broadcast_msg["cancel"] = False
        last_broadcast_msg["message_id_map"] = {}
        last_broadcast_msg["target_message"] = message.reply_to_message

        for idx, user_id in enumerate(users, 1):
            if last_broadcast_msg.get("cancel", False):
                break

            msg_id = await send_msg(user_id, message.reply_to_message)
            if msg_id:
                done += 1
                last_broadcast_msg["message_id_map"][user_id] = msg_id
            else:
                failed += 1

            if idx % 10 == 0 or idx == len(users):
                try:
                    await status_msg.edit_text(
                        f"üì§  ô Ä·¥è·¥Ä·¥Ö·¥Ñ·¥Äs·¥õ…™…¥…¢...\n\n‚úÖ {done}/{len(users)} s·¥á…¥·¥õ | ‚ùå {failed} “ì·¥Ä…™ ü·¥á·¥Ö",
                        reply_markup=cancel_btn
                    )
                except:
                    pass
            await asyncio.sleep(0.1)

        if last_broadcast_msg.get("cancel", False):
            await status_msg.edit_text(
                f"üî¥  ô Ä·¥è·¥Ä·¥Ö·¥Ñ·¥Äs·¥õ ·¥Ñ·¥Ä…¥·¥Ñ·¥á ü ü·¥á·¥Ö!\n\n‚úÖ {done} s·¥á…¥·¥õ | ‚ùå {failed} “ì·¥Ä…™ ü·¥á·¥Ö"
            )
        else:
            await status_msg.edit_text(
                f"‚úÖ ** ô Ä·¥è·¥Ä·¥Ö·¥Ñ·¥Äs·¥õ ·¥Ñ·¥è·¥ç·¥ò ü·¥á·¥õ·¥á·¥Ö**\n\nüì® `{done}` s·¥á…¥·¥õ\n‚ö†Ô∏è `{failed}` “ì·¥Ä…™ ü·¥á·¥Ö",
                parse_mode=ParseMode.MARKDOWN
            )
        last_broadcast_msg["cancel"] = False

    @app.on_message(filters.command("delete_gcast") & filters.user(OWNER_ID))
    async def delete_gcast(_, message: Message):
        msg_map = last_broadcast_msg.get("message_id_map", {})
        if not msg_map:
            return await message.reply("‚ÑπÔ∏è …¥·¥è  ô Ä·¥è·¥Ä·¥Ö·¥Ñ·¥Äs·¥õ  ú…™s·¥õ·¥è Ä è “ì·¥è·¥ú…¥·¥Ö.")

        confirm_btns = InlineKeyboardMarkup([[ 
            InlineKeyboardButton("‚úÖ Confirm Delete", callback_data="confirm_delete"),
            InlineKeyboardButton("‚ùå Cancel", callback_data="cancel_delete")
        ]])
        prompt = await message.reply(
            f"‚ö†Ô∏è Do you want to delete the last broadcast from `{len(msg_map)}` users?\n"
            "This will remove the message from their chats.\n‚è≥ Auto-cancels in 60 seconds.",
            reply_markup=confirm_btns,
            parse_mode=ParseMode.MARKDOWN
        )

        try:
            cbq = await app.listen(message.chat.id)
            if cbq.from_user.id != OWNER_ID:
                return await cbq.answer("‚ùå Not allowed.", show_alert=True)
        except asyncio.TimeoutError:
            return await prompt.edit("‚ùå **Delete operation timed out.**", reply_markup=None)

        if cbq.data == "cancel_delete":
            return await cbq.message.edit("‚ùå **Deletion cancelled.**", reply_markup=None)

        deleted, failed = 0, 0
        for user_id, msg_id in msg_map.items():
            try:
                await app.delete_messages(user_id, msg_id)
                deleted += 1
            except Exception:
                failed += 1

        await cbq.message.edit(
            f"üóëÔ∏è **Broadcast Deletion Completed**\n\n"
            f"‚úÖ `{deleted}` deleted\n‚ùå `{failed}` failed",
            parse_mode=ParseMode.MARKDOWN
        )
        last_broadcast_msg["message_id_map"] = {}

    @app.on_callback_query(filters.regex("cancel_broadcast"))
    async def cancel_callback(_, query: CallbackQuery):
        if query.from_user.id != OWNER_ID:
            return await query.answer("‚ùå  è·¥è·¥ú' Ä·¥á …¥·¥è·¥õ ·¥Ä ü ü·¥è·¥°·¥á·¥Ö ·¥õ·¥è ·¥Ñ·¥Ä…¥·¥Ñ·¥á ü ·¥õ ú…™s!", show_alert=True)

        last_broadcast_msg["cancel"] = True
        try:
            await query.message.edit("üî¥ **Broadcast cancelled.**", reply_markup=None)
        except:
            pass
